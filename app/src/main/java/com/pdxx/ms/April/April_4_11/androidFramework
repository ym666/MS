android framework 包含三个小伙伴 服务端 客户端 linux
服务端 windowmanagerservice  activitymanagerservice
客户端 activityThread activity window phonemanager 等
Linux  binder

一个activity最少包含三个线程
UIThread APPlicationThread ViewRoot.W

activity生命周期

onCreate onRestart onStart onResume  onSaveInstance onPause onStop onDestory

注意的点 A-B 在A不可见的时候先走的onPause
然后走B的 onCreate onStart onResume
最后走A的onSaveInstanceState onStop
所以如果要在一个activity不可见的时候做操作应该在onPause 但不能做耗时操作避免影响下个activity的生命周期

在一个activity打开dialog 或者下来通知 不会走onPause

如果设置一个activity为singleTop或者singleTask 或者singleInstance 那么重启启动时会调用onnewIntent方法

onSaveInstanceStata只在跳转到另一个acitivy时候会调用，如果手动finish，则不会调用，换句话说，onSaveInstance只会在
activity被动回收时候调用，在主动结束时不会调用

如果设置一个activityluanchmode为singleInstance 那么在开启时屏幕会明显闪一下，重复调用也会走onnewIntent 方法
singleInstance是另在一个栈里新建，为其他所有acitvity公用

在当前activity在栈顶时，如果有通知操作是进入这个activity，不想重复打开的话，那么要在onNewIntent中接收数据，并把activity设置为
singleInstance方法，如果不想再manifest里声明，可以在Intent中设置flag,并且此方法比在manifest中声明优先级要高。

具体
相当于singleTop
intent.addFlag(INTENT_ACTIVITY_SINGLE_TOP)
相当于singleTask
intent.addFlag(INTENT_ACTIVITY_CLEAR_TOP) //打开相机要加这个避免重复打开相机造成内存泄漏
相当于singleStanard
intent.addFlag(INTENT_ACTION_NEW_TASK)
//把整个栈的activity全杀死然后重建
intent.addFlag(INTENT_ACTIVITY_CLEAR_TASK)
